# 처리율 제한 장치의 설계

- DoS 공격 막기
- 제3자 API를 사용하는 서비스들은 해당 API의 사용률을 제한하는 것이 비용 절감에 좋다.
- 처리율 제한 장치는 미들웨어 혹은 서버에 둘 수 있다.
  - 제3자 서비스를 이용(미들웨어)하거나 자체적으로 서버에 구현할 수 있다.

## 처리율 제한 알고리즘

### 토큰 버킷

- 주기적으로 토큰이 리필되는 '토큰 버켓'을 사용하여 토큰이 존재할 때만 리퀘스트를 처리하고, 토큰이 없으면 리퀘스트를 버린다. 리퀘스트마다 토큰이 하나씩 소모된다.
- 토큰 공급률(refill rate): 초당 몇 개의 토큰이 버켓에 공급되는가
- 초당 최대 리퀘스트 처리량을 제한할 수 있다.
- 통상적으로 API 엔드포인트마다 토큰 버켓을 별도로 둔다.
  - 시스템의 초당 처리률에 제한을 두거나, 유저별로 엔드포인트마다 하루 사용량 제한을 두는 등 여러 방식으로 응용 가능하다.
- 구현이 쉽고 짧은 시간에 집중되는 트래픽도 감당할 수 있다. 버킷에 토큰을 추가하기만 하면 된다.
- 메모리 사용 측면에서도 효율적이다.

### 누출 버킷 알고리즘

- 토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어 있다.
- FIFO 큐를 사용한다. 일정 시점마다 큐에서 요청들을 꺼내서 처리하고, 큐가 가득 차있으면 요청이 버려진다. 큐가 곧 버킷이 된다.
- 큐의 크기가 고정되어 있기 때문에 메모리 사용량이 안정적이다.
- 고정된 처리율을 가지고 있어서 안정적 출력이 필요할 때 적합하다.
- 하지만 단시간 트래픽이 몰리는 경우에는 최신 요쳥들이 버려질 가능성이 있다.

### 고정 윈도우 카운터 알고리즘

- 시간을 일정 간격으로 윈도우를 두고, 요청이 들어오면 윈도우의 카운터를 증가시킨다. 카운터가 임계치를 넘어서면 그 이상으 요청은 버려진다.
- 윈도우가 전환되는 사이 시간에 트래픽이 몰리면 순간적으로 윈도우에 할당된 양보다 더 많이 요청이 처리될 수 있다. 따라서 고정적인 처리량을 기대하기는 어렵다.
- 메모리 효율이 매우 좋다.
- 특정한 트래픽 패턴을 처리하기에 적합하다(?)

### 이동 윈도 로깅 알고리즘

- 요청마다 타임스탬프를 추적한다. 새 요청이 오면 새로운 타임스탬프를 기준으로 만료된 타임스탬프들을 로그에서 제거한다.
- 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다.
- 시간당 처리량을 일정하게 유지할 수 있다.
- 하지만 거부된 타임스탬프도 메모리에 저장되므로 메모리 효율은 좋지 않은 편이다.

### 이동 윈도 카운터 알고리즘

- 이동하는 윈도우가 이전 윈도우와 현재 윈도우에 걸친 비율을 이용해서 현재 윈도우에 처리량을 계산한다.
- 메모리 효율이 좋고, 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
- 이전 윈도우의 처리 분포가 균등하다고 생각하고 계산하기에 정확한 계산은 아니다. 하지만 실제 실험에 따르면 그렇게 크게 차이가 나지는 않는다고 한다.

## 구현

- 레디스같은 인메모리 데이터베이스를 주로 사용한다.

나머지는 내일 적어야지
